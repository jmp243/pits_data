---
title: "PITS_quarto"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

### load libraries

```{r}
# load libraries 
library(plotly)
library(tidyverse)
library(readr)
library(crosstalk)
library(lubridate)
```

## Read in PITS data

```{r}
# read in data
PITS_ListIncidents_2023 <- read_csv("~/data librarian/PITS_Data/PITS_ListIncidents_2023.csv")
PITS_ListIncidents_2023$`Incident ID` <- as.character(PITS_ListIncidents_2023$`Incident ID`)
PITS_ListIncidents_2023$Time <- as.character(PITS_ListIncidents_2023$Time)

PITS_ListIncidents_2024 <- read_csv("~/data librarian/PITS_Data/PITS_ListIncidents_2024.csv")

PITS_ListIncidents_2024 <- PITS_ListIncidents_2024[,-(21:25)] 

PITS_ListIncidents_2025 <- read_csv("~/data librarian/PITS_Data/PITS_ListIncidents_Jan2025-March13_2025.csv")

# merge the years
PITS_2023_2025 <- rbind(PITS_ListIncidents_2023, PITS_ListIncidents_2024, PITS_ListIncidents_2025)

```

### Count unique reporters

```{r}
PITS_2023_2025 %>% summarise(count = n_distinct(Reporter))

# as.list(unique(PITS_2023_2024$Reporter))

```

## Mask Reporter IDs

```{r}
# Generate unique alternate IDs
# Function to generate consistent masked IDs
generate_consistent_ids <- function(names) {
  # Create a unique mapping of original names to masked IDs
  unique_names <- unique(names)
  masked_ids <- paste0("ID_", sprintf("%04d", seq_along(unique_names)))
  
  # Create a named vector for easy lookup
  id_mapping <- setNames(masked_ids, unique_names)
  
  # Map the original names to their consistent masked IDs
  return(id_mapping[names])
}

# Generate consistent masked IDs
PITS_2023_2025$masked_reporter <- generate_consistent_ids(PITS_2023_2025$Reporter)

# Create a lookup table
lookup_table_reporter <- PITS_2023_2025 %>%
  select(original_name = Reporter, masked_reporter) %>%
  distinct()

```

```{r}
# Turn follow-up into a binary 
# none versus other text
PITS_2023_2025 <- PITS_2023_2025 %>% 
  mutate(Followup_binary = ifelse(Followup == "NONE", 0, 1))

```

```{r}
# save a copy of the data without discerning columns
PITS_2023_2025_public <- 
  PITS_2023_2025 %>%
  select(-Reporter, -People, -Followup, -Description)

```

## Add datetime PITS data

```{r}
#| echo: false
# change date 
PITS_2023_2025_public$Date2 <- as.Date(PITS_2023_2025_public$Date, format = "%m/%d/%Y")


```

The `echo: false` option disables the printing of code (only output is displayed).

# Clean up the Time format in PITS

```{r}
# Using rowwise() to parse time

# remove NA times
# PITS_2023_2025_public <- PITS_2023_2025_public %>% 
#   filter(!is.na(Time))

PITS_2023_2025_public <- PITS_2023_2025_public %>%
  rowwise() %>%
  mutate(
    # Process one row at a time
    time_parsed = {
      time_str <- Time
      if (is.na(time_str) || !is.character(time_str)) {
        NA
      } else if (grepl("AM|PM", time_str, ignore.case = TRUE)) {
        parse_date_time(time_str, orders = c("I:M p", "H:M p"))
      } else if (grepl(":", time_str, fixed = TRUE)) {
        if (length(gregexpr(":", time_str)[[1]]) == 2) {
          parse_date_time(time_str, orders = "H:M:S")
        } else {
          parse_date_time(time_str, orders = "H:M")
        }
      } else {
        NA
      }
    }
  ) %>%
  ungroup() %>%
  mutate(
    time_24h = format(time_parsed, "%H:%M:%S"),
    time_12h = format(time_parsed, "%I:%M:%S %p")
  )

```

```{r}
# PITS_2023_2024_subset <- PITS_2023_2025 %>% 
#   filter(between(Date2, as.Date('2023-11-24'), as.Date('2024-11-24')))
```

## Standardize Location format

```{r}
# match location standard for computer use
# location name consistency 
# Create a master location mapping table
location_mapping <- data.frame(
  standard_name = c(
    "Joel D. Valdez-Main", "Himmel Park", "Murphy-Wilmot", "Woods Memorial",
    "Valencia", "Martha Cooper", "Flowing Wells", "Sahuarita",
    "Wheeler Taft Abbett", "Miller-Golf Links", "Eckstrom-Columbus",
    "Santa Rosa", "Sam Lena-South Tucson", "Oro Valley", "Quincie Douglas",
    "Bookmobile/Readrunners", "Caviglia-Arivaca", "Dewhirst-Catalina", 
    "Dusenberry-River", "El Rio", "Frank De La Cruz-El Pueblo",
    "Joyner-Green Valley", "Kirk-Bear Canyon", "Nanini", 
    "Richard Elias-Mission", "Salazar-Ajo", "Southwest",
    "W. Anne Gibson-Esmond Station", "Web Renewal"
  ),
  stringsAsFactors = FALSE
)

# Function to standardize location names
standardize_location <- function(location) {
  # Remove common suffixes
  location <- gsub(" Branch Library$|\\s+Library$", "", location)
  
  # Handle specific cases
  location <- gsub("^Joel Valdez Main$", "Joel D. Valdez-Main", location)
  location <- gsub("^Joel D Valdez Main$", "Joel D. Valdez-Main", location)
  location <- gsub("^Bookmobile-Readrunners$", "Bookmobile/Readrunners", location)
  location <- gsub("^Quincie Douglas$", "Quincie Douglas", location)
  location <- gsub("^Virtual Library$", "Web Renewal", location)
  
  # Return the standardized name
  return(location)
}

# Apply standardization to each dataset
standardize_dataset <- function(df, location_col_name) {
  if(location_col_name %in% colnames(df)) {
    df$Location_Standard <- standardize_location(df[[location_col_name]])
    return(df)
  } else {
    warning(paste("Column", location_col_name, "not found in dataset"))
    return(df)
  }
}

# Apply to all three datasets
PITS_2023_2025_public <- standardize_dataset(PITS_2023_2025_public, "Location")
# last52weeks_circ <- standardize_dataset(last52weeks_circ, "Location")
# last52weeks_comp <- standardize_dataset(last52weeks_comp, "Location")

```

# hourly summary of PITS from Jan 2023 to March 2025

```{r}
# group pits incidents by the hour

# Assuming your data is in a data frame called 'df' with a column 'timestamp'
# Group by hour
PITS_2023_2025_public$hour_group <- floor_date(PITS_2023_2025_public$time_parsed, unit = "hour")

# For visualization/labeling, you can format the hour
PITS_2023_2025_public$hour_label <- format(PITS_2023_2025_public$hour_group, "%H:00-%H:59")


```

```{r}
# remove NA dates
PITS_2023_2025_public <- PITS_2023_2025_public %>% 
  filter(!is.na(Date))
```


```{r}
# bring in the data
PITS_2023_2025_public  <- read_csv("data/pits2023-2025-public.csv")
```

```{r}
# # Group by hour and count events
hourly_summary <- PITS_2023_2025_public %>%
  select(hour_label, Location, Infractions, time_parsed, Date2) %>%
  # mutate(hour_group = floor_date(time_parsed, unit = "hour")) %>%
  group_by(hour_label) %>%
  summarize(
    Total_Hourly_Count = n(),
    # other aggregate metrics as needed
  )

hourly_location_date_summary <- PITS_2023_2025_public %>%
  select(hour_label, hour_group, Location_Standard, time_parsed, Date2) %>%
  # Group by date as well as hour and location
  group_by(Date2, hour_label, Location_Standard) %>%
  summarize(
    count = n(),
    .groups = "drop"
  ) %>%
  # Create a wide format with Location combinations as columns
  pivot_wider(
    id_cols = c(Date2, hour_label),  # Keep Date2 as an identifier column
    names_from = Location_Standard,
    values_from = count,
    values_fill = 0
  )

# more information 
hourly_location_summary <- PITS_2023_2025_public %>%
  select(hour_label, hour_group, Location_Standard, time_parsed, Date2) %>% 
  # mutate(hour_group = floor_date(time_parsed, unit = "hour")) %>%
  group_by(hour_label, Location_Standard) %>%
  summarize(
    count = n(),
    .groups = "drop"
  ) %>%
  # Create a wide format with Location combinations as columns
  pivot_wider(
    names_from = c(Location_Standard),
    values_from = count,
    values_fill = 0
  )



# join the two charts
hourly_loc_sum_total <-  hourly_summary %>% 
                                    left_join(hourly_location_date_summary)
```

# Visualize hourly data

```{r}
# Basic interactive bar chart of hourly counts
plot_hourly <- plot_ly(hourly_loc_sum_total,
                       x = ~hour_label,
                       y = ~Total_Hourly_Count,
                       type = "bar",
                       name = "Total") %>%
  layout(title = "Events by Hour",
         xaxis = list(title = "Hour of Day", tickangle = 45),
         yaxis = list(title = "Number of Events"),
         hovermode = "compare")

# For location breakdown, convert to long format first
hourly_loc_long <- hourly_loc_sum_total %>%
  pivot_longer(
    cols = -c(hour_label, Total_Hourly_Count, Date2),
    names_to = "Location",
    values_to = "Count"
  )

# Interactive stacked bar chart by location
plot_by_location <- plot_ly(hourly_loc_long,
                           x = ~hour_label,
                           y = ~Count,
                           color = ~Location,
                           type = "bar") %>%
  layout(title = "Events by Location and Hour",
         xaxis = list(title = "Hour of Day", tickangle = 45),
         yaxis = list(title = "Number of Events"),
         barmode = "stack",
         hovermode = "compare")

# Display the plots
plot_hourly

```

# Visualize with location

```{r}
# plot_by_location
# Here's how to add interactivity to highlight a single location:
# rCopy
# Create a plotly visualization with buttons to filter by location
# locations <- unique(hourly_loc_long$Location)
# 
# # Create a list of buttons, one for each location plus "All"
# buttons <- list(
#   list(
#     method = "update",
#     args = list(list(visible = rep(TRUE, length(locations))),
#                 list(title = "Events by Location and Hour - All Locations")),
#     label = "All"
#   )
# )
# 
# # Add a button for each location
# for(i in 1:length(locations)) {
#   visible <- rep(FALSE, length(locations))
#   visible[i] <- TRUE
#   
#   buttons <- c(buttons, list(
#     list(
#       method = "update",
#       args = list(list(visible = visible),
#                   list(title = paste0("Events by Location and Hour - ", locations[i]))),
#       label = locations[i]
#     )
#   ))
# }
# 
# # Create the base plot
# plot_by_location <- plot_ly()
# 
# # Add each location as a separate trace
# for(i in 1:length(locations)) {
#   loc_data <- filter(hourly_loc_long, Location == locations[i])
#   
#   plot_by_location <- plot_by_location %>%
#     add_trace(
#       data = loc_data,
#       x = ~hour_label,
#       y = ~Count,
#       type = "bar",
#       name = locations[i],
#       marker = list(color = colorRampPalette(c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728"))(length(locations))[i])
#     )
# }

# # Add the buttons and layout
# plot_by_location <- plot_by_location %>%
#   layout(
#     title = "Events by Location and Hour",
#     xaxis = list(title = "Hour of Day", tickangle = 45),
#     yaxis = list(title = "Number of Events"),
#     barmode = "stack",
#     hovermode = "compare",
#     updatemenus = list(
#       list(
#         type = "dropdown",
#         buttons = buttons,
#         direction = "down",
#         showactive = TRUE,
#         x = 1.1,
#         y = 0.5
#       )
#     )
#   )
# 
# # Add double-click functionality for highlighting
# plot_by_location <- plot_by_location %>%
#   layout(
#     legend = list(
#       itemclick = "toggleothers",
#       itemdoubleclick = "toggle"
#     )
#   )
# 
# # Display the plot
# plot_by_location
```

```{r}
# Create a plotly visualization with buttons to filter by location but no legend
locations <- sort(unique(hourly_loc_long$Location))  # Sort locations alphabetically

# Create a list of buttons, one for each location plus "All"
buttons <- list(
  list(
    method = "update",
    args = list(list(visible = rep(TRUE, length(locations))),
                list(title = "Events by Location and Hour - All Locations")),
    label = "All"
  )
)

# Add a button for each location in alphabetical order
for(i in 1:length(locations)) {
  visible <- rep(FALSE, length(locations))
  visible[i] <- TRUE
  
  buttons <- c(buttons, list(
    list(
      method = "update",
      args = list(list(visible = visible),
                  list(title = paste0("Events by Location and Hour - ", locations[i]))),
      label = locations[i]
    )
  ))
}

# Create the base plot
plot_by_location <- plot_ly()

# Add each location as a separate trace
for(i in 1:length(locations)) {
  loc_data <- filter(hourly_loc_long, Location == locations[i])
  
  plot_by_location <- plot_by_location %>%
    add_trace(
      data = loc_data,
      x = ~hour_label,
      y = ~Count,
      type = "bar",
      name = locations[i],
      marker = list(color = colorRampPalette(c("#1f77b4", "#ff7f0e", "#2ca02c", "#d62728"))(length(locations))[i])
    )
}

# Add the buttons and layout - moved to upper left and removed legend
plot_by_location <- plot_by_location %>%
  layout(
    title = "Events by Location and Hour",
    xaxis = list(title = "Hour of Day", tickangle = 45),
    yaxis = list(title = "Number of Events"),
    barmode = "stack",
    hovermode = "compare",
    showlegend = FALSE,  # Remove the legend
    updatemenus = list(
      list(
        type = "dropdown",
        buttons = buttons,
        direction = "down",
        showactive = TRUE,
        x = 1.1,
        y = 1
    ))
  )

# Display the plot
plot_by_location
```

```{r}
# remove if date is na

hourly_loc_long <- hourly_loc_long %>%
  filter(!is.na(Date2))

```

```{r}
library(usethis) 
usethis::edit_r_environ()
```

```{r}
# More efficient approach
hourly_location_summary <- PITS_2023_2025_public %>%
  # Select only necessary columns to reduce memory usage
  select(hour_label, Location_Standard, Date2) %>%
  # Pre-aggregate to reduce data size before pivoting
  count(Date2, hour_label, Location_Standard, name = "count") %>%
  # Now pivot with the smaller dataset
  pivot_wider(
    id_cols = c(Date2, hour_label),
    names_from = Location_Standard,
    values_from = count,
    values_fill = 0
  )
```

```{r}
# Process by date chunks
library(dplyr)

# Get unique dates
unique_dates <- unique(PITS_2023_2025_public$Date2)
# Process in chunks of 30 days
chunk_size <- 30
date_chunks <- split(unique_dates, ceiling(seq_along(unique_dates)/chunk_size))

# Initialize empty result dataframe
hourly_location_summary <- data.frame()

# Process each chunk
for(chunk in date_chunks) {
  temp_df <- PITS_2023_2025_public %>%
    filter(Date2 %in% chunk) %>%
    select(hour_label, Location_Standard, Date2) %>%
    count(Date2, hour_label, Location_Standard, name = "count") %>%
    pivot_wider(
      id_cols = c(Date2, hour_label),
      names_from = Location_Standard,
      values_from = count,
      values_fill = 0
    )
  
  # Append to result
  hourly_location_summary <- bind_rows(hourly_location_summary, temp_df)
}

```

```{r}
library(plotly)
library(dplyr)

# getting tge date tune slider but this only produced a date drop down
# Get unique dates and locations
dates <- sort(unique(hourly_loc_long$Date2))
locations <- sort(unique(hourly_loc_long$Location))

# Create a base plot
p <- plot_ly()

# Add traces for each location
for (loc in locations) {
  loc_data <- filter(hourly_loc_long, Location == loc)
  p <- p %>% add_trace(
    data = loc_data,
    x = ~hour_label,
    y = ~Count,
    type = "bar",
    name = loc,
    transforms = list(
      list(
        type = 'filter',
        target = ~Location,
        operation = '=',
        value = loc
      ),
      list(
        type = 'filter',
        target = ~Date2,
        operation = 'in',
        value = dates[1]  # Default to first date
      )
    )
  )
}

# Create location filter buttons
loc_buttons <- lapply(c("All", locations), function(loc) {
  if (loc == "All") {
    list(
      method = "update",
      args = list(
        list(visible = rep(TRUE, length(locations))),
        list(title = "Events by Location and Hour - All Locations")
      ),
      label = "All Locations"
    )
  } else {
    visible <- rep(FALSE, length(locations))
    visible[match(loc, locations)] <- TRUE
    list(
      method = "update",
      args = list(
        list(visible = visible),
        list(title = paste0("Events by Location and Hour - ", loc))
      ),
      label = loc
    )
  }
})

# Create date filter buttons (showing only first 10 dates if there are many)
date_buttons <- lapply(dates[1:min(10, length(dates))], function(date) {
  list(
    method = "restyle",
    args = list(
      "transforms[1].value", date
    ),
    label = as.character(date)
  )
})

# Add buttons and layout
p <- p %>%
  layout(
    title = "Events by Location and Hour",
    xaxis = list(title = "Hour of Day", tickangle = 45),
    yaxis = list(title = "Number of Events"),
    barmode = "stack",
    hovermode = "compare",
    showlegend = TRUE,
    updatemenus = list(
      # Location filter
      list(
        type = "dropdown",
        active = 0,
        buttons = loc_buttons,
        direction = "down",
        showactive = TRUE,
        x = 0.1,
        y = 1.1,
        name = "Location Filter"
      ),
      # Date filter 
      list(
        type = "dropdown",
        active = 0,
        buttons = date_buttons,
        direction = "down",
        showactive = TRUE,
        x = 0.4,
        y = 1.1,
        name = "Date Filter"
      )
    )
  )

p
```

```{r}
library(plotly)
library(dplyr)
library(crosstalk)

# Convert hourly_location_summary to long format if needed
hourly_loc_long <- hourly_location_summary %>%
  pivot_longer(
    cols = -c(Date2, hour_label),
    names_to = "Location",
    values_to = "Count"
  )

# Make sure Date2 is a proper Date object
hourly_loc_long$Date2 <- as.Date(hourly_loc_long$Date2)

hourly_loc_long2 <- hourly_loc_long %>%
  filter(!is.na(hour_label))

# Create a shared data object
sd <- SharedData$new(hourly_loc_long2)

# Create the plotly visualization
p <- plot_ly(sd, x = ~hour_label, y = ~Count, color = ~Location, type = "bar") %>%
  layout(
    title = "Events by Location and Hour",
    xaxis = list(title = "Hour of Day", tickangle = 45),
    yaxis = list(title = "Number of Events"),
    barmode = "stack",
    hovermode = "compare",
    showlegend = FALSE
  )
# Create filter panel
filter_panel <- list(
  filter_slider("Date2", "Date Range", sd, ~Date2, width = "100%"),
  filter_select("Location", "Location", sd, ~Location, multiple = TRUE)
)


```

JavaScript to help produce a prettier image
```{js, echo=FALSE}

var fitTheScreen = window.setInterval(function(){
  if ( $(".irs-from").text() === $(".irs-min").text() ) {
    $(".irs-from").css({"left": "10%"});
  }

  if ( $(".irs-to").text() === $(".irs-max").text() ) {
    $(".irs-to").css({"left": "86%"});
  }

}, 1000);

```

```{r}
# Combine filters with plot
bscols(
  widths = c(3, 9),
  filter_panel,
  p
)
```

```{r}
# Get unique dates and sort them
dates <- sort(unique(as.Date(hourly_loc_long$Date2)))
min_date <- min(dates)
max_date <- max(dates)

# Create dropdown buttons for locations
locations <- sort(unique(hourly_loc_long$Location))
buttons <- list(
  list(
    method = "update",
    args = list(list(visible = rep(TRUE, length(locations))),
                list(title = "Events by Location and Hour - All Locations")),
    label = "All"
  )
)

for(i in 1:length(locations)) {
  visible <- rep(FALSE, length(locations))
  visible[i] <- TRUE
  
  buttons <- c(buttons, list(
    list(
      method = "update",
      args = list(list(visible = visible),
                  list(title = paste0("Events by Location and Hour - ", locations[i]))),
      label = locations[i]
    )
  ))
}

# First, create a long-format dataset with dates
date_filtered_data <- hourly_loc_long %>%
  group_by(Date2, hour_label, Location) %>%
  summarize(Count = sum(Count, na.rm = TRUE), .groups = "drop")

# Create base plot with date as a third variable
plot_by_location <- plot_ly(date_filtered_data, 
                           x = ~hour_label, 
                           y = ~Count,
                           color = ~Location,
                           frame = ~Date2,  # This creates animation frames by date
                           type = "bar") %>%
  layout(
    title = "Events by Location and Hour",
    xaxis = list(title = "Hour of Day", tickangle = 45),
    yaxis = list(title = "Number of Events"),
    barmode = "stack",
    hovermode = "compare",
    showlegend = FALSE,
    updatemenus = list(
      # Location dropdown
      list(
        type = "dropdown",
        buttons = buttons,
        direction = "down",
        showactive = TRUE,
        x = 0.1,
        y = 0.9
      ),
      # Animation controls
      list(
        type = "buttons",
        x = 0.1,
        y = 0.8,
        buttons = list(
          list(method = "animate", args = list(NULL, list(frame = list(duration = 500, redraw = TRUE), fromcurrent = TRUE)), label = "Play"),
          list(method = "animate", args = list(NULL, list(frame = list(duration = 0, redraw = TRUE), mode = "immediate")), label = "Pause")
        )
      )
    ),
    # Add date slider
    sliders = list(
      list(
        currentvalue = list(
          prefix = "Date: ",
          xanchor = "right"
        ),
        steps = lapply(unique(date_filtered_data$Date2), function(date) {
          list(
            method = "animate",
            args = list(
              list(frame = as.character(date)),
              list(mode = "immediate", transition = list(duration = 300), frame = list(duration = 300, redraw = TRUE))
            ),
            label = as.character(date)
          )
        })
      )
    )
  )

# Add animation settings
plot_by_location <- plot_by_location %>%
  animation_opts(
    frame = 1000,
    transition = 500,
    easing = "linear",
    redraw = FALSE
  ) %>%
  animation_slider(
    currentvalue = list(prefix = "Date: ", font = list(color = "black"))
  )

# Display the plot
plot_by_location
```

```{r}

```

```{r}
# attempt to add the min/max date filter
library(plotly)
library(dplyr)
library(crosstalk)

```

## Write csv

```{r}
write.csv(PITS_2023_2025_public, "pits2023-2025-public.csv")
```
