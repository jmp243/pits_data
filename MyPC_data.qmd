
---
title: "MyPC_data"
format: html
editor: visual
---

```{r}
library(readr)
library(tidyverse)
MyPC_2023 <- read_csv("~/data librarian/MyPC_data/MyPC_2023_siteAndLocationUsage.csv", 
                      skip = 15)
MyPC_2024 <- read_csv("~/data librarian/MyPC_data/MyPC_2024_siteAndLocationUsage.csv", 
                      skip = 15)
MyPC_2025 <- read_csv("~/data librarian/MyPC_data/MyPC_Mar19_2025_siteAndLocationUsage.csv", 
                      skip = 15)
MyPC_all <- rbind(MyPC_2023, MyPC_2024, MyPC_2025)

# View(MyPC_2023)
```

Aggregated MyPC data

```{r}
# drop all test cases
MyPC_public <- MyPC_all %>% 
  filter(Site != "Test") %>% 
  select(-Name)
```

Convert id into character

```{r}
MyPC_public$`Login ID` <- as.character(MyPC_public$`Login ID`)
```

# create a new column to parse out the date

```{r}
library(lubridate)

# Create new date variable with lubridate
MyPC_public <- MyPC_public %>%
  mutate(booking_from = mdy_hm(`Booking From`))

MyPC_public <- MyPC_public %>%
  mutate(booking_date = as.Date(`Booking From`, format = "%m/%d/%Y"))

# Create new date variable from login time
# MyPC_public$Booking_time <- format(as.POSIXct(MyPC_public$`Booking From`), format = "%H:%M")
#   # mutate(hms = lubridate::hms(substr(`Booking From`, 11, nchar(`Booking From`))))

MyPC_public <- MyPC_public %>%
 mutate(booking_time = format(booking_from, format = "%H:%M:%S"))
```

# Rename Location and Site columns

```{r}
as.list(unique(MyPC_public$Site))

MyPC_public <- MyPC_public %>%
  rename(Location_detail = Location) %>%
  rename(Location = Site)

```

# standardize location

```{r}
# Create a master location mapping table
location_mapping <- data.frame(
  standard_name = c(
    "Joel D. Valdez-Main", "Himmel Park", "Murphy-Wilmot", "Woods Memorial",
    "Valencia", "Martha Cooper", "Flowing Wells", "Sahuarita",
    "Wheeler Taft Abbett", "Miller-Golf Links", "Eckstrom-Columbus",
    "Santa Rosa", "Sam Lena-South Tucson", "Oro Valley", "Quincie Douglas",
    "Bookmobile/Readrunners", "Caviglia-Arivaca", "Dewhirst-Catalina", 
    "Dusenberry-River", "El Rio", "Frank De La Cruz-El Pueblo",
    "Joyner-Green Valley", "Kirk-Bear Canyon", "Nanini", 
    "Richard Elias-Mission", "Salazar-Ajo", "Southwest",
    "W. Anne Gibson-Esmond Station", "Web Renewal"
  ),
  stringsAsFactors = FALSE
)

# Function to standardize location names
standardize_location <- function(location) {
  # Remove common suffixes
  location <- gsub(" Branch Library$|\\s+Library$", "", location)
  
  # Handle specific cases
  location <- gsub("^Joel Valdez Main$", "Joel D. Valdez-Main", location)
  location <- gsub("^Joel D Valdez Main$", "Joel D. Valdez-Main", location)
  location <- gsub("^Bookmobile-Readrunners$", "Bookmobile/Readrunners", location)
  location <- gsub("^Quincie Douglas$", "Quincie Douglas", location)
  location <- gsub("^Virtual Library$", "Web Renewal", location)
  
  # Return the standardized name
  return(location)
}

# Apply standardization to each dataset
standardize_dataset <- function(df, location_col_name) {
  if(location_col_name %in% colnames(df)) {
    df$Location_Standard <- standardize_location(df[[location_col_name]])
    return(df)
  } else {
    warning(paste("Column", location_col_name, "not found in dataset"))
    return(df)
  }
}

# Apply to all three datasets
MyPC_public <- standardize_dataset(MyPC_public, "Location")


# # For merging datasets
# merge_by_location <- function(df1, df2, by.x = "Location_Standard", by.y = "Location_Standard", ...) {
#   merge(df1, df2, by.x = by.x, by.y = by.y, ...)
# }

```

```{r}
as.list(unique(MyPC_public$Location_Standard))
```

```{r}
# # Open MyPC data
# MyPC_public <- read_csv("data/MyPC_2023-2025-public.csv")
# MyPC_public <- MyPC_public[,-1]  
```

## generate a consistent ID
```{r}
generate_consistent_logins <- function(logins) {
  # Create a unique mapping of original names to masked IDs
  unique_names <- unique(logins)
  masked_logins <- paste0("ID_", sprintf("%04d", seq_along(unique_names)))
  
  # Create a named vector for easy lookup
  login_mapping <- setNames(masked_logins, unique_names)
  
  # Map the original names to their consistent masked IDs
  return(login_mapping[logins])
}

# Generate consistent masked IDs
MyPC_public$masked_logins <- generate_consistent_logins(MyPC_public$`Login ID`)

# Create a lookup table
lookup_table_reporter <- MyPC_public %>%
  select(original_name = `Login ID`, masked_logins) %>%
  distinct()

```

```{r}
# remove orig login from new table
MyPC_public <- MyPC_public %>% 
  select(-`Login ID`)
```

```{r}
names(MyPC_public)
```

```{r}


```

## graph with plotly
```{r}
# make tables similar to pits
library(plotly)
library(dplyr)
library(crosstalk)
library(lubridate)

# First, prepare the data
MyPC_public <- MyPC_public %>%
  mutate(
    # # Make sure booking_from is properly parsed
    # booking_from = if(!inherits(`Booking From`, "POSIXct")) 
    #                  as.POSIXct(`Booking From`) else `Booking From`,
    # Extract hour for grouping
    hour_of_day = hour(booking_from),
    hour_label = paste0(hour_of_day, ":00")
  )

# Aggregate data by hour and location
hourly_usage <- MyPC_public %>%
  group_by(hour_label, Location_Standard, booking_date) %>%
  summarize(count = n(), .groups = "drop") %>%
  arrange(as.numeric(substr(hour_label, 1, 2)))

# Create shared data object for filtering
sd <- SharedData$new(hourly_usage)

# Create the plotly visualization
p <- plot_ly(sd, 
             x = ~hour_label, 
             y = ~count, 
             color = ~Location_Standard, 
             type = "bar",
             hovertemplate = ~paste(
               "Hour: ", hour_label,
               "<br>Location: ", Location_Standard,
               "<br>Count: ", count,
               "<br>Date: ", format(booking_date, "%Y-%m-%d"),
               "<extra></extra>"
             )) %>%
  layout(
    title = "Computer Usage by Hour of Day",
    xaxis = list(
      title = "Hour of Day", 
      tickangle = 45,
      categoryorder = "array",
      categoryarray = paste0(0:23, ":00")
    ),
    yaxis = list(title = "Number of Sessions"),
    barmode = "stack",
    hovermode = "compare",
     showlegend = FALSE  # Remove legend
  )
# Create the filter controls
# filters <- list(
#   filter_select("Location_Standard", "Location", sd, ~Location_Standard, multiple = TRUE),
#   filter_slider("booking_date", "Date Range", sd, ~booking_date, width = "100%")
# )

# Create the filter panel correctly
location_filter <- filter_select("location", "Location", sd, ~Location_Standard, multiple = TRUE)
date_filter <- filter_slider("date", "Date Range", sd, ~booking_date, width = "100%")


# Combine the filters and plot
bscols(
  widths = c(3, 9),
  filter_panel,
  p
)
```
# create a ratio graph

```{r}
library(dplyr)
library(plotly)
library(crosstalk)
library(htmltools)

# Step 1: Prepare and aggregate both datasets
# Aggregate PITS data by location and date
PITS_counts <- PITS_2023_2025_public %>%
  # Make sure date is in proper format
  mutate(date = as.Date(Date)) %>%
  group_by(Location_Standard, date) %>%
  summarize(infraction_count = n(), .groups = "drop")

# Aggregate MyPC data by location and date
MyPC_counts <- MyPC_public %>%
  # select(booking_date, Location_Standard) %>% 
  # Make sure date is in proper format
  # mutate(date = as.Date(`Booking From`)) %>%
  rename(date = booking_from) %>% 
  group_by(Location_Standard, date) %>%
  summarize(user_count = n(), .groups = "drop")

# Step 2: Join the datasets
ratio_data <- MyPC_counts %>%
  full_join(PITS_counts, by = c("Location_Standard", "date")) %>%
  # Handle any missing values
  mutate(
    infraction_count = ifelse(is.na(infraction_count), 0, infraction_count),
    user_count = ifelse(is.na(user_count), 0, user_count)
  )

# Step 3: Calculate the ratio
ratio_data <- ratio_data %>%
  # Avoid division by zero
  mutate(
    ratio = ifelse(user_count > 0, infraction_count / user_count, 0),
    # Multiply by 100 to get percentage
    ratio_percentage = ratio * 100
  )

# Step 4: Create the interactive visualization
# Create shared data object for filtering
sd <- SharedData$new(ratio_data)

# Create the plotly visualization
p <- plot_ly(sd, 
             x = ~date, 
             y = ~ratio_percentage, 
             color = ~Location_Standard, 
             type = "scatter",
             mode = "lines+markers",
             hovertemplate = ~paste(
               "Date: ", format(date, "%Y-%m-%d"),
               "<br>Location: ", Location_Standard,
               "<br>Infractions: ", infraction_count,
               "<br>Users: ", user_count,
               "<br>Ratio: ", sprintf("%.2f%%", ratio_percentage),
               "<extra></extra>"
             )) %>%
  layout(
    title = "Ratio of PITS Infractions to MyPC Users by Location",
    xaxis = list(title = "Date"),
    yaxis = list(title = "Infraction Rate (%)"),
    hovermode = "closest"
  )

# Create the filter panel
location_filter <- filter_select("location", "Location", sd, ~Location_Standard, multiple = TRUE)
date_filter <- filter_slider("date", "Date Range", sd, ~date, width = "100%")

# Combine the filters and plot
bscols(
  widths = c(3, 9),
  div(
    location_filter,
    date_filter
  ),
  p
)
```


```{r}
# ratio visualization 
# Add a second plot showing the raw counts
counts_plot <- plot_ly(sd) %>%
  add_trace(
    x = ~date,
    y = ~infraction_count,
    name = "Infractions",
    type = "bar",
    marker = list(color = "red")
  ) %>%
  add_trace(
    x = ~date,
    y = ~user_count,
    name = "Users",
    type = "bar",
    marker = list(color = "blue")
  ) %>%
  layout(
    title = "Raw Counts: Infractions vs Users",
    xaxis = list(title = "Date"),
    yaxis = list(title = "Count"),
    barmode = "group"
  )

# Display both plots
bscols(
  widths = c(3, 9),
  div(
    location_filter,
    date_filter
  ),
  div(
    p,
    counts_plot
  )
)

```

### Save csv

```{r}
write.csv(MyPC_public, "MyPC_2023-2025-public.csv")
```